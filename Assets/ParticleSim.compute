#pragma kernel K_ReactDecay
#pragma kernel K_PhysicsMove
#pragma kernel K_Render
#pragma kernel K_Paint
#pragma kernel K_Sample

#define EMPTY 0
#define WATER 1
#define FIRE 2
#define EARTH 3
#define PLANT 4
#define AIR 5

#define NONE 0
#define LIQUID 1
#define SOLID 2
#define GAS 3

#define OWNER_ENV 0
#define OWNER_PLAYER 1
#define OWNER_BOSS 2

#define MAX_ENERGY 100.0
#define FIRE_DECAY_RATE 15.0
#define AIR_DECAY_RATE 10.0
#define FIRE_DAMAGE_TO_WATER 2.0
#define WATER_DAMAGE_TO_FIRE 20.0
#define FIRE_BURN_DAMAGE 5.0
#define NEW_FIRE_ENERGY 50.0

#define GRAVITY 9.8
#define BUOYANCY 12.0
#define MAX_FALL_SPEED 30.0
#define MAX_RISE_SPEED 25.0
#define HARD_LANDING_THRESHOLD 8.0

#define REACTION_PUSH_FORCE 15.0
#define ATTACK_BOUNCE_FORCE 10.0

struct ParticleCell
{
    int elementType;
    int physicalState;
    float currentEnergy;
    float2 velocity;
    uint is_attack;
    uint owner;
};

struct SpawnData
{
    int2 position;
    ParticleCell cell;
};

RWStructuredBuffer<ParticleCell> Grid_Read;
RWStructuredBuffer<ParticleCell> Grid_Write;
RWTexture2D<float4> OutputTexture;
StructuredBuffer<SpawnData> SpawnBuffer;

StructuredBuffer<int2> SampleCoordsBuffer;
RWStructuredBuffer<ParticleCell> SampleResultsBuffer;

int _WorldWidth;
int _WorldHeight;
float _DeltaTime;
int _SpawnCount;
int _SampleCount;
int _SimFrameOffset;

uint GetIndex(int2 id)
{
    if (id.x < 0 || id.x >= _WorldWidth || id.y < 0 || id.y >= _WorldHeight)
        return 0;
    return (uint)id.x + (uint)id.y * _WorldWidth;
}

ParticleCell CreateEmpty()
{
    ParticleCell empty;
    empty.elementType = EMPTY;
    empty.physicalState = NONE;
    empty.currentEnergy = 0;
    empty.velocity = float2(0, 0);
    empty.is_attack = 0;
    empty.owner = 0;
    return empty;
}

float GetRandom(float2 co)
{
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

[numthreads(8, 8, 1)]
void K_ReactDecay(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint index = GetIndex((int2)dispatchThreadID.xy);
    ParticleCell self = Grid_Read[index];

    if (self.elementType == EMPTY)
    {
        Grid_Write[index] = self;
        return;
    }

    if (self.elementType == FIRE)
        self.currentEnergy -= FIRE_DECAY_RATE * _DeltaTime;
    else if (self.elementType == AIR)
        self.currentEnergy -= AIR_DECAY_RATE * _DeltaTime;
        
    bool reacted = false;

    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            if (x == 0 && y == 0) continue;

            int2 n_pos = (int2)dispatchThreadID.xy + int2(x, y);
            uint n_index = GetIndex(n_pos);
            ParticleCell neighbor = Grid_Read[n_index];

            if (neighbor.elementType == EMPTY) continue;
            
            float2 pushDir = normalize(float2(x, y));

            if (self.elementType == WATER && neighbor.elementType == FIRE)
            {
                self.currentEnergy -= FIRE_DAMAGE_TO_WATER * _DeltaTime;
                self.velocity += pushDir * REACTION_PUSH_FORCE * _DeltaTime;
                if (neighbor.is_attack) self.is_attack = 0;
                reacted = true;
            }
            else if (self.elementType == FIRE && neighbor.elementType == WATER)
            {
                self.currentEnergy -= WATER_DAMAGE_TO_FIRE * _DeltaTime;
                self.velocity += pushDir * REACTION_PUSH_FORCE * _DeltaTime;
                if (neighbor.is_attack) self.is_attack = 0;
                reacted = true;
            }
            else if (self.elementType == PLANT && neighbor.elementType == FIRE)
            {
                self.currentEnergy -= FIRE_BURN_DAMAGE * _DeltaTime;
                if (self.currentEnergy <= 0)
                {
                    self.elementType = FIRE;
                    self.physicalState = LIQUID;
                    self.currentEnergy = NEW_FIRE_ENERGY;
                    self.is_attack = 0;
                }
                reacted = true;
            }
            
            if (self.is_attack == 1 && self.owner != neighbor.owner)
            {
                if (neighbor.physicalState == SOLID || neighbor.elementType == WATER)
                {
                    self.is_attack = 0;
                    self.velocity = -self.velocity * 0.5 + pushDir * ATTACK_BOUNCE_FORCE;
                }
            }
        }
    }
    
    if (self.currentEnergy <= 0)
    {
        self = CreateEmpty();
    }

    Grid_Write[index] = self;
}

[numthreads(8, 8, 1)]
void K_PhysicsMove(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint index = GetIndex((int2)dispatchThreadID.xy);
    ParticleCell self = Grid_Read[index];
    
    if (self.physicalState == NONE)
    {
        Grid_Write[index] = self;
        return;
    }
    
    float2 rand = float2(GetRandom(dispatchThreadID.xy), GetRandom(dispatchThreadID.xy + 0.1));
    int simDir = (rand.x > 0.5) ? 1 : -1;
    if (((int)dispatchThreadID.x + (int)dispatchThreadID.y + _SimFrameOffset) % 2 == 0) simDir *= -1;

    if (self.physicalState == SOLID || self.physicalState == LIQUID)
    {
        self.velocity.y -= GRAVITY * _DeltaTime;
    }
    else if (self.physicalState == GAS)
    {
        self.velocity.y += BUOYANCY * _DeltaTime;
    }
    
    self.velocity.y = clamp(self.velocity.y, -MAX_FALL_SPEED, MAX_RISE_SPEED);
    self.velocity.x *= 0.95;

    int2 targetPos = (int2)dispatchThreadID.xy + (int2)round(self.velocity * _DeltaTime);
    int2 originalPos = (int2)dispatchThreadID.xy;

    if (self.physicalState == SOLID)
    {
        int2 pos_below = originalPos + int2(0, -1);
        uint index_below = GetIndex(pos_below);
        ParticleCell cell_below = Grid_Read[index_below];
        
        if (cell_below.physicalState == NONE) targetPos = pos_below;
        else
        {
            int2 diag_pos = originalPos + int2(simDir, -1);
            uint diag_index = GetIndex(diag_pos);
            ParticleCell diag_cell = Grid_Read[diag_index];

            if (diag_cell.physicalState == NONE) targetPos = diag_pos;
            else if (abs(self.velocity.y) > HARD_LANDING_THRESHOLD && cell_below.physicalState == SOLID)
            {
                int2 side_pos = originalPos + int2(simDir, 0);
                if (Grid_Read[GetIndex(side_pos)].physicalState == NONE)
                {
                    targetPos = side_pos;
                    self.velocity.x = self.velocity.y * simDir * 0.5;
                }
                else
                {
                    self.velocity = float2(0, 0);
                }
            }
            else
            {
                self.velocity = float2(0, 0);
            }
        }
    }
    else if (self.physicalState == LIQUID)
    {
        int2 pos_below = originalPos + int2(0, -1);
        if (Grid_Read[GetIndex(pos_below)].physicalState == NONE) targetPos = pos_below;
        else
        {
            int2 diag_pos = originalPos + int2(simDir, -1);
            if (Grid_Read[GetIndex(diag_pos)].physicalState == NONE) targetPos = diag_pos;
            else
            {
                int2 side_pos = originalPos + int2(simDir, 0);
                if (Grid_Read[GetIndex(side_pos)].physicalState == NONE) targetPos = side_pos;
                else self.velocity = float2(0, 0);
            }
        }
    }
    else if (self.physicalState == GAS)
    {
        int2 pos_above = originalPos + int2(0, 1);
        if (Grid_Read[GetIndex(pos_above)].physicalState == NONE) targetPos = pos_above;
        else
        {
            int2 diag_pos = originalPos + int2(simDir, 1);
            if (Grid_Read[GetIndex(diag_pos)].physicalState == NONE) targetPos = diag_pos;
            else
            {
                int2 side_pos = originalPos + int2(simDir, 0);
                if (Grid_Read[GetIndex(side_pos)].physicalState == NONE) targetPos = side_pos;
                else self.velocity = float2(0, 0);
            }
        }
    }
    
    if ((targetPos.x != originalPos.x || targetPos.y != originalPos.y) &&
        targetPos.x >= 0 && targetPos.x < _WorldWidth &&
        targetPos.y >= 0 && targetPos.y < _WorldHeight)
    {
        uint targetIndex = GetIndex(targetPos);
        if (Grid_Read[targetIndex].physicalState == NONE)
        {
            Grid_Write[index] = CreateEmpty();
            Grid_Write[targetIndex] = self;
        }
        else
        {
            Grid_Write[index] = self;
        }
    }
    else
    {
        Grid_Write[index] = self;
    }
}

[numthreads(8, 8, 1)]
void K_Render(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint index = GetIndex((int2)dispatchThreadID.xy);
    ParticleCell cell = Grid_Read[index];
    
    float4 color = float4(0, 0, 0, 0);
    
    if (cell.elementType == WATER)
        color = float4(0.2, 0.5, 1.0, 1.0);
    else if (cell.elementType == FIRE)
        color = float4(1.0, lerp(0.2, 0.8, cell.currentEnergy / MAX_ENERGY), 0.0, 1.0);
    else if (cell.elementType == EARTH)
        color = float4(0.5, 0.3, 0.1, 1.0);
    else if (cell.elementType == PLANT)
        color = float4(0.1, 0.8, 0.2, 1.0);
    else if (cell.elementType == AIR)
        color = float4(0.8, 0.8, 0.9, 0.5);
        
    if (cell.is_attack == 1)
        color.rgb = lerp(color.rgb, float3(1,1,1), 0.5);

    OutputTexture[dispatchThreadID.xy] = color;
}

[numthreads(64, 1, 1)]
void K_Paint(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int id = (int)dispatchThreadID.x;
    if (id >= _SpawnCount) return;
    
    SpawnData spawn = SpawnBuffer[id];
    uint index = GetIndex(spawn.position);
    
    ParticleCell oldCell = Grid_Write[index];
    
    if (oldCell.physicalState == NONE || spawn.cell.is_attack == 1)
    {
        Grid_Write[index] = spawn.cell;
        
        if (oldCell.physicalState != NONE && spawn.cell.is_attack == 1)
        {
            int2 pushPos = spawn.position + int2(1, 0);
            if(Grid_Write[GetIndex(pushPos)].physicalState == NONE)
            {
                oldCell.velocity = spawn.cell.velocity * 0.5;
                Grid_Write[GetIndex(pushPos)] = oldCell;
            }
        }
    }
}

[numthreads(64, 1, 1)]
void K_Sample(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int id = (int)dispatchThreadID.x;
    
    if (id >= _SampleCount) return;

    int2 coord = SampleCoordsBuffer[id];
    uint index = GetIndex(coord);
    
    SampleResultsBuffer[id] = Grid_Read[index];
}

